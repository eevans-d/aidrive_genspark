# Mega Plan — O1 Facturas Por Imagen + O2 Deposito

- Fecha (UTC): `2026-02-23 01:47:35`
- Revision final: `2026-02-23` (verificacion cruzada contra codebase real)
- Objetivo: definir y ejecutar una ruta concreta para completar:
  - O1 (inmediato): procesamiento de facturas desde imagen/foto.
  - O2 (siguiente): consolidacion final del modulo Deposito.

## 1) Decision De Prioridad

1. Si, es correcto priorizar O1 (facturas por imagen) como objetivo inmediato.
2. Condicion tecnica: O1 requiere cerrar 2 dependencias de base antes de escalar:
   - modelo de alias de productos (tabla `producto_aliases` — no existe hoy en BD),
   - modelo de persistencia de precio de compra interno (feature nuevo; D-007 fue cerrada en D-153 removiendo el insert desalineado, pero la persistencia de costo queda diferida como feature futura).
3. O2 no arranca de cero: esta mayormente implementado y debe completarse en fase de integracion con O1 para evitar retrabajo.

## 2) Situacion Real Actual (verificada contra codebase 2026-02-23)

### O1 — Facturas por imagen

| Item | Estado | Evidencia | Impacto |
|---|---|---|---|
| OCR/factura por foto implementado | A_CREAR | Sin resultados para OCR/factura/invoice en `minimarket-system/src`, `supabase/functions`, `scripts`. No existe Edge Function OCR ni librerias OCR/document parsing en runtime actual. | No existe pipeline automatico de lectura. |
| Modelo SQL de facturas de proveedor (headers/items) | A_CREAR | Sin tablas `facturas_*` ni `comprobante` en migraciones SQL actuales. Sin definiciones en `database.types.ts`. | No hay tabla canonica para ingesta de factura. |
| Endpoint backend para upload documento (multipart/form-data) | A_CREAR | Gateway `api-minimarket/index.ts` usa enrutamiento por `path+method` con multiples guards; ninguno acepta `multipart/form-data` ni `request.formData()`. | No existe endpoint de carga de imagen de factura. |
| Persistencia de imagen en storage para facturas | A_CREAR | Sin uso de `supabase.storage` ni `storage.from()` en frontend ni backend. Sin bucket configurado para facturas. | No hay bucket/flujo de archivos en app para facturas. |
| Reutilizable: captura con camara | REAL (parcial) | `minimarket-system/src/components/BarcodeScanner.tsx` — usa `@zxing/library` `BrowserMultiFormatReader`. Tiene permisos de camara, video overlay, fallback manual. Limitado a barcode scanning (video stream, no foto). | Base UX de captura reutilizable; requiere adaptacion para captura de foto/archivo de factura. |
| Reutilizable: criterio de afinamiento por proveedor | REAL (documentado) | `docs/closure/PLAN_AJUSTE_PREPRODUCCION_FACTURAS_Y_LENGUAJE_2026-02-22.md` — criterio de pase por proveedor (precision >=95%, errores criticos=0, tiempo <=3min). | Metodologia de piloto ya validada operativamente. |
| Reutilizable: parser deterministico de texto libre | REAL | `minimarket-system/src/utils/cuadernoParser.ts` — `parseNote()` extrae accion/producto/cantidad/prioridad/proveedor. Matching basico de productos por nombre (`.includes()`) en linea 147-153. `resolveProveedor()` con confianza alta/media/sin_match. | Base para matching de producto desde texto de factura; insuficiente para match robusto (no tiene aliases ni fuzzy). |

### O2 — Deposito

| Item | Estado | Evidencia | Impacto |
|---|---|---|---|
| UI Deposito con modo rapido/normal | REAL | `Deposito.tsx:10` (`type TabMode = 'rapido' | 'normal'`), `Deposito.tsx:275` (tab toggle "Ingreso Rapido"). Lineas 290-399: modo rapido. Lineas 402-607: modo normal. | Operacion diaria de entradas/salidas ya disponible. |
| Ajustes con validacion de motivo | REAL | `Deposito.tsx:208-213` (validacion: motivo obligatorio para ajustes), `Deposito.tsx:555-569` (render condicional del campo motivo). | Control basico de calidad operativo. |
| API frontend de movimientos | REAL | `apiClient.ts:410-420` — `depositoApi.movimiento()` con `MovimientoParams` (producto_id, tipo, cantidad, motivo, proveedor_id). | FE puede registrar movimientos en gateway. |
| Endpoints backend de deposito/compras | REAL | `api-minimarket/index.ts:1443` (`POST /deposito/movimiento` — usa `sp_movimiento_inventario`), `index.ts:1592` (`POST /deposito/ingreso` — ingreso de mercaderia), `index.ts:1701` (`POST /compras/recepcion` — recepcion atomica por orden de compra con FOR UPDATE). | Backend preparado para movimientos, ingreso y recepcion. 3 endpoints operativos. |
| Concurrencia y locks en SP inventario | REAL | `supabase/migrations/20260217200000_vuln003_004_concurrency_locks.sql` — `sp_movimiento_inventario` con `FOR UPDATE` en `stock_deposito` y `ordenes_compra`. `sp_actualizar_pago_pedido` con `FOR UPDATE`. CHECK constraint `stock_no_negativo` (`cantidad_actual >= 0`). | Base robusta para alta concurrencia. TOCTOU race conditions eliminadas. |
| Kardex operativo + export | REAL | `Kardex.tsx:40` — `handleExportCsv()` con headers + rows. Filtrado por producto y lote. Resumen con contadores entrada/salida/ajuste. | Trazabilidad de movimientos disponible con export CSV. |
| Tests UI Deposito/Kardex | REAL | `Deposito.test.tsx` 6 tests (render, tabs, modo rapido, seleccion producto, modo normal, boton deshabilitado). `Kardex.test.tsx` 1 smoke test. `frontend-hooks.test.ts` 5 tests de logica Kardex. Total: 12 tests directos. | Calidad base validada en frontend. |
| Persistencia de precio de compra interno | A_CREAR (feature nueva) | `api-minimarket/index.ts:1643-1648` — comentario D-007/D-153: `precio_compra` se acepta en request body pero NO se persiste. `precios_proveedor` es de scraping. Persistencia diferida hasta modelo dedicado. Nota: `productos.precio_costo` existe (campo nullable) pero no tiene historial ni trazabilidad por factura. | Gap clave para integrar facturas con costos. |
| Flujo FE dedicado para `compras/recepcion` | A_CREAR | `depositoApi` en `apiClient.ts` solo expone `movimiento()`. No hay metodo para `/deposito/ingreso` ni `/compras/recepcion`. No hay pagina `Compras.tsx` ni `Recepcion.tsx` en frontend. | Endpoint existe en backend (3 endpoints completos), falta recorrido UI completo. |

## 3) Blockers Reales (P0)

1. **Modelo de datos**: O1 no puede arrancar en produccion sin modelo SQL (factura + items + estado de validacion). Tablas `facturas_ingesta`, `facturas_ingesta_items`, `facturas_ingesta_eventos` no existen.
2. **Alias de producto**: O1 no puede cerrar ciclo de negocio sin tabla `producto_aliases` y reglas de matching multinivel. El parser actual (`cuadernoParser.ts:147-153`) solo hace `.includes()` basico sin aliases.
3. **Costo interno**: Integracion O1->O2 queda incompleta mientras `precio_compra` interno no tenga persistencia dedicada. D-007 cerrada en D-153 (insert desalineado eliminado), pero la persistencia de costo es un feature nuevo pendiente.
4. **Storage/bucket**: No existe bucket de Supabase Storage configurado para imagenes de facturas. Requiere creacion y configuracion de RLS para storage.
5. **Seleccion de servicio OCR**: No hay decision sobre que servicio usar para extraccion (Google Vision, AWS Textract, API de Claude Vision, Tesseract local, etc.). Impacta costo, precision y arquitectura de la Edge Function.

## 4) Production Readiness Score (actual)

### O1 Facturas Por Imagen
- Score estimado: `15/100`
- Justificacion: sin OCR runtime, sin storage, sin modelo SQL, sin endpoint upload, sin UI de validacion de factura. Solo hay base parcial reutilizable (camara para barcode, parser de texto libre basico, criterio de piloto por proveedor).

### O2 Deposito
- Score estimado: `78/100`
- Justificacion: modulo funcional en FE/BE + tests + SP robusto + Kardex con export + concurrencia resuelta; faltan: persistencia de costo interno dedicado, flujo FE para recepcion por orden/factura, metodos en `apiClient.ts` para `/deposito/ingreso` y `/compras/recepcion`.

### Global (ambos objetivos combinados)
- Score actual combinado: `46/100`
- Calculo: promedio ponderado (O1=15, O2=78, peso igual).

## 5) Plan De Ejecucion Optimo (fases)

### Fase 0 — Fundacion comun

**Prerequisito de todas las fases siguientes. No iniciar Fase 1 sin Gate A aprobado.**

#### Tarea 0.0 — Decision de servicio OCR
- Evaluar opciones:
  - **Google Cloud Vision API**: alta precision, costo por request (~$1.50/1000 paginas).
  - **Claude Vision API (Anthropic)**: buena precision para facturas estructuradas, costo por tokens.
  - **Tesseract (self-hosted)**: gratuito pero menor precision en facturas complejas.
  - **AWS Textract**: optimizado para documentos, costo por pagina.
- DoD:
  - decision registrada en `docs/DECISION_LOG.md`,
  - secret/API key provisionada en Supabase secrets (nombre, no valor),
  - costo estimado por factura documentado.

#### Tarea 0.1 — Modelo SQL de facturas de ingreso
- Crear tablas en migracion versionada:
  - `facturas_ingesta` (cabecera: proveedor_id FK, tipo_comprobante, numero, fecha_factura, total, estado, imagen_url, datos_extraidos jsonb, score_confianza, request_id, created_by).
  - `facturas_ingesta_items` (lineas: factura_id FK, descripcion_original, producto_id FK nullable, alias_usado, cantidad, unidad, precio_unitario, subtotal, estado_match, confianza_match).
  - `facturas_ingesta_eventos` (auditoria: factura_id FK, evento, datos jsonb, usuario_id, created_at).
- Estados de factura: `pendiente|extraida|validada|aplicada|error|rechazada`.
- Estados de match por item: `auto_match|alias_match|fuzzy_pendiente|confirmada|rechazada`.
- DoD:
  - migracion versionada aplicada sin drift (`supabase db push`),
  - constraint de idempotencia UNIQUE: `(proveedor_id, tipo_comprobante, numero, fecha_factura)`,
  - RLS ENABLED con policies: SELECT (admin, deposito), INSERT/UPDATE (admin, deposito), DELETE (admin),
  - grants a anon revocados,
  - `database.types.ts` regenerado (`supabase gen types typescript`),
  - tests de contrato para las nuevas tablas.

#### Tarea 0.2 — Modelo alias de producto
- Crear tabla `producto_aliases` en migracion versionada:
  - `id` uuid PK,
  - `alias_texto` text NOT NULL (normalizado: lowercase, sin acentos, trim),
  - `alias_normalizado` text NOT NULL GENERATED (para busqueda invariante),
  - `producto_id` uuid NOT NULL FK -> productos(id) ON DELETE CASCADE,
  - `proveedor_id` uuid NULL FK -> proveedores(id) ON DELETE SET NULL,
  - `confianza` text NOT NULL DEFAULT 'media' CHECK IN ('alta','media','baja'),
  - `origen` text NULL (manual, ocr, cuaderno),
  - `activo` boolean NOT NULL DEFAULT true,
  - `created_at` timestamptz DEFAULT now(),
  - `created_by` uuid NULL.
- Indice UNIQUE: `(alias_normalizado, proveedor_id) NULLS NOT DISTINCT` para evitar duplicados (incluyendo aliases globales sin proveedor). Fallback PostgreSQL <15: indice parcial UNIQUE `(alias_normalizado) WHERE proveedor_id IS NULL`.
- Indice: `(producto_id)` para busqueda inversa.
- DoD:
  - busqueda por alias exacto + normalizado funcional,
  - seed inicial con aliases reales de negocio (top 50-100 terminos),
  - integracion con `cuadernoParser.ts` para resolver producto por alias (capa 2 de matching),
  - RLS ENABLED: SELECT (todos), INSERT/UPDATE (admin, deposito), DELETE (admin),
  - tests unitarios para normalizacion y busqueda.

#### Tarea 0.3 — Modelo de costo interno (feature nuevo, complementa D-007)
- **Dependencia**: esta migracion debe tener timestamp posterior a Tarea 0.1 (FK a `facturas_ingesta_items`).
- Crear tabla `precios_compra` en migracion versionada:
  - `id` uuid PK,
  - `producto_id` uuid NOT NULL FK -> productos(id) ON DELETE CASCADE,
  - `proveedor_id` uuid NULL FK -> proveedores(id) ON DELETE SET NULL,
  - `precio_unitario` numeric(12,2) NOT NULL,
  - `factura_ingesta_item_id` uuid NULL FK -> facturas_ingesta_items(id) ON DELETE SET NULL,
  - `origen` text NOT NULL DEFAULT 'manual' CHECK IN ('manual','factura','recepcion'),
  - `created_at` timestamptz DEFAULT now(),
  - `created_by` uuid NULL.
- Indice: `(producto_id, created_at DESC)` para obtener ultimo costo.
- Indice: `(proveedor_id, producto_id)`.
- Modificar `POST /deposito/ingreso` (`index.ts:1592`) para persistir en `precios_compra` cuando se envia `precio_compra`.
- Actualizar `productos.precio_costo` con el ultimo valor registrado (trigger o en handler).
- DoD:
  - endpoint `/deposito/ingreso` persiste costo interno sin romper `precios_proveedor` (scraping),
  - cardinalidad correcta: 1 producto puede tener N registros de costo historico,
  - decision registrada en `docs/DECISION_LOG.md`.

#### Tarea 0.4 — Supabase Storage bucket para facturas
- Crear bucket `facturas` en Supabase Storage.
- Configurar policies de storage:
  - upload: solo usuarios autenticados con rol admin/deposito,
  - download: solo usuarios autenticados con rol admin/deposito,
  - max file size: 10MB,
  - tipos permitidos: image/jpeg, image/png, image/webp, application/pdf.
- DoD:
  - bucket creado y accesible desde frontend,
  - migracion o script de configuracion documentado,
  - test de upload/download funcional.

### Fase 1 — O1 MVP factura por imagen

**Prerequisito: Gate A aprobado.**

#### Tarea 1.1 — API frontend para deposito/ingreso y compras/recepcion
- Agregar a `apiClient.ts`:
  - `depositoApi.ingreso()` -> `POST /deposito/ingreso` (producto_id, cantidad, proveedor_id, precio_compra, deposito).
  - `depositoApi.recepcionCompra()` -> `POST /compras/recepcion` (orden_compra_id, cantidad, deposito).
- DoD:
  - tipos TypeScript definidos para request/response,
  - tests unitarios para los nuevos metodos.

#### Tarea 1.2 — UI de carga y preview
- Nueva pantalla: `Compras > Facturas` (ruta `/facturas`).
- Componentes:
  - `FacturaUpload.tsx`: input file (camara y/o archivo imagen/PDF), preview de imagen, boton "Extraer".
  - Estado de carga/error/exito con skeleton.
- Flujo:
  1. usuario selecciona imagen o toma foto,
  2. imagen se sube a bucket `facturas` via Supabase Storage,
  3. se crea registro `facturas_ingesta` con estado `pendiente`,
  4. se invoca Edge Function `facturas-ocr`.
- DoD:
  - usuario puede cargar imagen desde archivo o camara,
  - imagen queda persistida en storage con referencia en `facturas_ingesta.imagen_url`,
  - estados de carga/error/vacio,
  - test de componente.

#### Tarea 1.3 — Edge Function de extraccion
- Nueva Edge Function: `facturas-ocr/index.ts`.
- Patron: `Deno.serve` + CORS + `requireServiceRoleAuth` (invocada desde server-side o con service key).
- Flujo:
  1. recibe `factura_id` (referencia al registro en `facturas_ingesta`),
  2. descarga imagen desde storage,
  3. invoca servicio OCR seleccionado (Tarea 0.0),
  4. parsea respuesta y extrae: proveedor, fecha, numero, tipo_comprobante, items (descripcion, cantidad, unidad, precio),
  5. guarda resultado estructurado en `facturas_ingesta.datos_extraidos` + `score_confianza`,
  6. crea registros en `facturas_ingesta_items` con estado `auto_match` o `fuzzy_pendiente`,
  7. ejecuta matching multinivel por cada item:
     - capa 1: codigo de barras/SKU exacto contra `productos.codigo_barras`/`productos.sku`,
     - capa 2: alias exacto normalizado contra `producto_aliases.alias_normalizado`,
     - capa 3: fuzzy contra `productos.nombre` (sin confirmar, estado `fuzzy_pendiente`),
  8. actualiza estado de factura a `extraida`,
  9. registra evento en `facturas_ingesta_eventos`.
- DoD:
  - timeout controlado (`AbortSignal.timeout`),
  - errores auditables por `request_id`,
  - sin exponer secretos de OCR,
  - deploy con `supabase functions deploy facturas-ocr`,
  - tests unitarios para parseo y matching.

#### Tarea 1.4 — Validacion humana asistida
- Componente `FacturaValidacion.tsx`:
  - tabla editable de items extraidos,
  - por cada item: producto_id resuelto (editable con dropdown), cantidad, precio, estado de match,
  - indicadores visuales de confianza (verde=auto_match, amarillo=alias_match, rojo=fuzzy_pendiente),
  - boton "Confirmar linea" / "Rechazar linea",
  - al confirmar linea con match manual: ofrecer guardar como nuevo alias en `producto_aliases`.
- Boton global: "Validar factura" (solo si todas las lineas estan en `confirmada` o `rechazada`).
- DoD:
  - toda linea queda en `confirmada` o `rechazada`,
  - correcciones manuales generan aliases nuevos (con `origen='manual'`),
  - estado de factura pasa a `validada`.

### Fase 2 — Integracion O1 -> O2

**Prerequisito: Gate B aprobado.**

#### Tarea 2.1 — Aplicar factura validada a inventario
- Accion desde UI: boton "Aplicar al deposito" (solo facturas en estado `validada`).
- Por cada item confirmado:
  - invocar `depositoApi.ingreso()` (usa `POST /deposito/ingreso` -> `sp_movimiento_inventario`),
  - persistir costo en `precios_compra` (Tarea 0.3),
  - actualizar `productos.precio_costo` con ultimo valor.
- Actualizar estado de factura a `aplicada`.
- Idempotencia: constraint UNIQUE en `facturas_ingesta_items.id` vinculado a `movimientos_deposito` previene doble aplicacion.
- DoD:
  - transaccion por factura (o por item con estado parcial),
  - rollback seguro si falla item critico,
  - no duplicar aplicacion por doble click/reintento (boton deshabilitado + verificacion de estado),
  - test de idempotencia.

#### Tarea 2.2 — Trazabilidad completa
- Agregar columna `factura_ingesta_item_id` uuid NULL FK a `movimientos_deposito` (migracion).
- Al aplicar factura, vincular cada movimiento con el item de factura correspondiente.
- Modificar Kardex UI (`Kardex.tsx`) para mostrar origen:
  - si `factura_ingesta_item_id` != null: mostrar icono/link "Factura #XXX - Proveedor YYY".
- DoD:
  - desde Kardex se puede rastrear origen (factura/proveedor) de cada movimiento,
  - test de componente.

### Fase 3 — Cierre O2 Deposito

**Prerequisito: Gate C aprobado.**

#### Tarea 3.1 — FE para `compras/recepcion`
- Componente integrado en pagina de Deposito o pagina nueva:
  - lista de ordenes de compra pendientes (`ordenes_compra` con estado `pendiente`),
  - boton "Recibir" por orden,
  - formulario: cantidad recibida, deposito destino,
  - invoca `depositoApi.recepcionCompra()`.
- DoD:
  - endpoint backend existente (`POST /compras/recepcion`) usable desde UI,
  - estados de error/carga/vacio completos (skeleton, empty state, error con requestId),
  - test de componente.

#### Tarea 3.2 — KPI operativos deposito+factura
- KPI minimos en Dashboard o pagina dedicada:
  - **Precision de matching**: % items con auto_match + alias_match vs total items extraidos (consulta sobre `facturas_ingesta_items`).
  - **Tiempo de validacion por factura**: diferencia entre `created_at` de factura y evento `validada` en `facturas_ingesta_eventos`.
  - **Tasa de lineas manuales**: % items en `fuzzy_pendiente` que requirieron correccion.
  - **Diferencias de costo detectadas**: comparar `precios_compra.precio_unitario` vs `productos.precio_costo` anterior.
- Implementacion: consultas SQL directas desde frontend (READ via Supabase client + RLS) o vista materializada.
- DoD:
  - metricas visibles para owner en Dashboard,
  - test de componente.

#### Tarea 3.3 — Tests integrales del flujo completo
- Tests E2E del flujo: upload -> extraccion -> validacion -> aplicacion -> Kardex.
- Tests unitarios para cada componente nuevo.
- Coverage: mantener >=80% global.
- DoD:
  - suite de tests PASS,
  - coverage no disminuye,
  - `pnpm -C minimarket-system build` PASS.

## 6) Prioridades Top 10 (accionables)

| Prioridad | Tarea | Impacto (1-3) | Riesgo | Fase |
|-----------|-------|:---:|--------|------|
| 1 | Seleccionar servicio OCR y provisionar secret | 3 | Alto (bloquea Fase 1) | 0 |
| 2 | Definir esquema SQL factura+items+eventos | 3 | Alto (bloquea todo O1) | 0 |
| 3 | Definir esquema SQL `producto_aliases` | 3 | Alto (bloquea matching) | 0 |
| 4 | Cerrar modelo `precios_compra` (feature nuevo) | 3 | Alto (bloquea integracion O1->O2) | 0 |
| 5 | Crear bucket Supabase Storage para facturas | 2 | Medio (bloquea upload) | 0 |
| 6 | Implementar EF de extraccion OCR con matching multinivel | 3 | Alto (nucleo de O1) | 1 |
| 7 | Implementar UI de carga + validacion humana | 2 | Medio | 1 |
| 8 | Implementar aplicacion idempotente factura->deposito | 3 | Alto (integridad de datos) | 2 |
| 9 | Exponer flujo FE `compras/recepcion` + vincular Kardex | 2 | Medio | 3 |
| 10 | Dashboard KPI de calidad de carga + tests integrales | 1 | Bajo | 3 |

## 7) Quality Gates Por Fase

### Gate A — Fundacion datos (tras Fase 0)
- Migraciones aplican en local sin errores (`supabase db push` o `db reset`).
- Migraciones aplican en linked sin drift (`supabase migration list --linked`).
- RLS ENABLED y grants validados en tablas nuevas (script `rls_fine_validation.sql`).
- Tests de contrato para nuevas tablas PASS.
- `database.types.ts` regenerado y consistente.
- Bucket `facturas` accesible.
- Decision de servicio OCR registrada en `docs/DECISION_LOG.md`.
- `npx vitest run` PASS (tests existentes no rompen).
- `pnpm -C minimarket-system build` PASS.

### Gate B — OCR MVP (tras Fase 1)
- Upload de imagen + extraccion + persistencia funcionan E2E (flujo completo manual).
- Tasa de match automatico >= 60% en lote de prueba de 10 facturas reales.
- Tasa de error de extraccion <= 10% (fallback a validacion manual cubre el resto).
- Edge Function `facturas-ocr` desplegada y respondiendo.
- Validacion humana permite confirmar/rechazar todas las lineas.
- Aliases nuevos se guardan correctamente.
- `npx vitest run` PASS.
- `pnpm -C minimarket-system lint` PASS.
- `pnpm -C minimarket-system build` PASS.

### Gate C — Integracion Deposito (tras Fase 2)
- Aplicacion de factura NO duplica movimientos (test de idempotencia).
- Stock y costos consistentes post-aplicacion (verificar `stock_deposito.cantidad_actual` y `precios_compra`).
- Kardex refleja origen con link a factura.
- `movimientos_deposito.factura_ingesta_item_id` vinculado correctamente.
- `npx vitest run` PASS.

### Gate D — Cierre operativo (tras Fase 3)
- `pnpm -C minimarket-system lint` PASS.
- `pnpm -C minimarket-system build` PASS.
- `npx vitest run` PASS (todos los tests, incluidos nuevos).
- Coverage >= 80% global.
- `node scripts/validate-doc-links.mjs` PASS.
- Flujo FE `compras/recepcion` operativo.
- KPIs visibles en Dashboard.
- Piloto por proveedor ejecutado con al menos 2 proveedores reales (criterio: precision >=95%).
- `docs/ESQUEMA_BASE_DATOS_ACTUAL.md` actualizado con tablas nuevas.
- `docs/API_README.md` actualizado con endpoints nuevos.

## 8) Riesgos Y Mitigacion

| # | Riesgo | Probabilidad | Impacto | Mitigacion |
|---|--------|:---:|:---:|---|
| 1 | OCR con baja precision en facturas de mala calidad (fotos borrosas, PDFs escaneados) | Alta | Alto | Score de confianza por campo + validacion humana obligatoria (nunca auto-aplicar sin revision). Fallback: carga manual asistida. |
| 2 | Duplicacion de ingresos por reintentos o doble click | Media | Critico | Llave idempotente UNIQUE (proveedor + tipo_comprobante + numero + fecha). Estado `aplicada` impide re-aplicacion. Boton deshabilitado durante request. |
| 3 | Mezcla de costos scraping vs costos internos | Baja | Alto | Tablas separadas: `precios_proveedor` (scraping) vs `precios_compra` (interno). Reglas de escritura explicitas por tabla. |
| 4 | Retrabajo por integrar O1 sin cerrar base O2 | Media | Alto | Ejecutar Fase 0 completa antes de Fase 1. Gate A es bloqueante. |
| 5 | Costo excesivo de API OCR en produccion | Media | Medio | Implementar rate limit por usuario/dia. Monitorear consumo. Budget alert si se supera umbral. |
| 6 | Aliases insuficientes para productos nuevos o variantes | Alta | Medio | Flujo de feedback: cada correccion manual genera alias nuevo. Seed inicial con top 100 terminos reales. Revision semanal de aliases rechazados. |
| 7 | Diferencia de formato entre proveedores | Alta | Medio | Parser configurable por proveedor (regex/templates). Piloto proveedor-por-proveedor antes de Go-Live (ver PLAN_AJUSTE). |
| 8 | Storage de imagenes crece sin control | Baja | Bajo | Politica de retencion: archivar imagenes >90 dias a tier economico. Max file size 10MB en policy de bucket. |

## 9) Dependencias entre tareas (grafo)

```
Tarea 0.0 (OCR decision) ──────────────────────────────────┐
Tarea 0.1 (SQL facturas) ──────────┬─────────────┐         │
Tarea 0.2 (SQL aliases)  ──────────┤             │         │
                                    │             ▼         │
Tarea 0.3 (SQL precios_compra) ─┐  │  [depende de 0.1]    │
Tarea 0.4 (Storage bucket) ──┐  │  │             │         │
                              │  │  │             │         │
                              ▼  ▼  ▼             ▼         ▼
                           [Gate A — Fundacion datos]
                                        │
                     ┌──────────────────┼──────────────────┐
                     ▼                  ▼                  ▼
              Tarea 1.1           Tarea 1.2           Tarea 1.3
          (API client FE)     (UI upload)         (EF extraccion)
                     │              │                  │
                     └──────────────┼──────────────────┘
                                    ▼
                              Tarea 1.4
                         (Validacion humana)
                                    │
                            [Gate B — OCR MVP]
                                    │
                     ┌──────────────┴──────────────┐
                     ▼                             ▼
              Tarea 2.1                      Tarea 2.2
       (Aplicar a inventario)         (Trazabilidad Kardex)
                     │                             │
                     └──────────────┬──────────────┘
                                    │
                       [Gate C — Integracion Deposito]
                                    │
                     ┌──────────────┼──────────────┐
                     ▼              ▼              ▼
              Tarea 3.1       Tarea 3.2       Tarea 3.3
        (FE recepcion)    (KPIs dashboard)  (Tests integrales)
                     │              │              │
                     └──────────────┴──────────────┘
                                    │
                          [Gate D — Cierre operativo]
```

## 10) Rollback por fase

| Fase | Estrategia de rollback |
|------|----------------------|
| Fase 0 | Revertir migraciones (DROP TABLE IF EXISTS para tablas nuevas). No impacta funcionalidad existente. |
| Fase 1 | Eliminar Edge Function `facturas-ocr`. Eliminar pagina `/facturas` y ruta. Datos en `facturas_ingesta` se mantienen como historico. |
| Fase 2 | Revertir columna `factura_ingesta_item_id` en `movimientos_deposito`. Kardex vuelve a modo sin origen. Stock ya aplicado NO se revierte automaticamente (requiere ajuste manual si es necesario). |
| Fase 3 | Eliminar pagina de recepcion y KPIs. Sin impacto en datos. |

## 11) Integracion con PLAN_AJUSTE (piloto por proveedor)

Este mega plan se integra con `docs/closure/PLAN_AJUSTE_PREPRODUCCION_FACTURAS_Y_LENGUAJE_2026-02-22.md`:

- **Fase 0** corresponde a "Semana 1 - Preparacion" del PLAN_AJUSTE (catalogo canonico + diccionario aliases).
- **Fase 1** corresponde a "Semanas 2-3 - Piloto Proveedores" (carga controlada por proveedor con validacion humana).
- **Criterio de pase por proveedor** del PLAN_AJUSTE se aplica en Gate B y Gate D:
  - Verde: precision >= 95% y 0 errores criticos en 2 corridas seguidas.
  - Amarillo: precision 90%-94% o errores criticos aislados.
  - Rojo: precision < 90% o errores de unidad/variante repetidos.
  - Regla: no avanzar de proveedor en estado Rojo.
- **KPIs minimos** del PLAN_AJUSTE se implementan en Tarea 3.2.

## 12) Veredicto Ejecutivo

1. **Priorizar O1 primero: SI**, pero con fundacion de datos solida (Fase 0) antes de tocar UI/OCR.
2. **Fase 0 es critica y bloqueante**: sin tablas de factura, aliases, precios de compra y bucket de storage, no se puede avanzar.
3. **Decision de servicio OCR (Tarea 0.0) es prerrequisito**: impacta costo, precision y arquitectura.
4. **O2 Deposito esta avanzado (78/100)** y se completa de forma natural en Fases 2-3 al integrar facturas.
5. **Piloto por proveedor es la estrategia correcta** para minimizar riesgo y maximizar calidad de datos.
6. **Reutilizar activos existentes**: `cuadernoParser.ts` para matching basico, `BarcodeScanner.tsx` como referencia de UX camara, `sp_movimiento_inventario` para transacciones atomicas, `productos_faltantes` como fuente de informacion de demanda.
